theory P1
begin

/*
  Assignment 1.1: MAC-based challenge response

  We model the following protocol:
    1. A -> B: x
    2. B -> A: [x]k(A,B)
  where x is a nonce generated by A
  k(A,B) is a uni-directional symmetric long-term key shared by A and B and
  [M]k denotes the MAC of message M with key K  
*/

builtins: symmetric-encryption
functions: mac/2
equations: mac(m,k) = <m,senc(m,k)>

rule Reveal_Key:
	[ !SymKey(X, k) ] 
	--[ Reveal(X) ]-> 
	[ Out(k) ]

rule Init_I:
	[ Fr(~k_IR) ] 
	--[ Secret($I,~k_IR), Honest($I), Honest($R), Role('I') ]->
	[ !SymKey($I,~k_IR)
	, !SymKey($R,~k_IR)
	] 

rule I_1_Send:
	[ AgSt($I,~k_IR), Fr(~x) ]
	--[ Send($I,~x), Role('I'), Commit(a,b,<'R','I',t>) ]->
	[ Out(~x)
	, AgSt($I,~x) 
	]

rule R_1_Recv:
	[ In(x) ]
	--[ Receive($R,x), Role('R'), Running(b,a,<'R','I',t>) ]->
	[ AgSt($R,x) ]

rule R_2_Send:
	[ AgSt($R,x), AgSt($R,~k_IR) ] 
	--[ Secret($R,~k_IR), Honest($R), Role('R'), Send($R,mac(x,~k_IR)) ]->
	[ Out(mac(x,~k_IR)) ] 

rule I_2_Recv:
	[ In(mac(x,~k_IR)) ]
	--[ Secret($I,~k_IR), Honest($I), Role('I'), Receive($I,mac(x,~k_IR)) ]->
	[ AgSt($I,mac(x,~k_IR))	]

lemma secrecy:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma secrecy_PFS:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i & r < i)"

lemma noninjectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a,b,<'I','R',t>) @i
    ==> (Ex #j. Running(b,a,<'I','R',t>) @j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma injectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a,b,<'I','R',t>) @i
    ==> (Ex #j. Running(b,a,<'I','R',t>) @j 
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>) @i2
                           & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma noninjectiveagreementRESPONDER:
  "All a b t #i. 
    Commit(a,b,<'R','I',t>) @i
    ==> (Ex #j. Running(b,a,<'R','I',t>) @j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma injectiveagreementRESPONDER:
  "All a b t #i. 
    Commit(a,b,<'R','I',t>) @i
    ==> (Ex #j. Running(b,a,<'R','I',t>) @j 
              & not (Ex a2 b2 #i2. Commit(a2,b2,<'R','I',t>) @i2
                                 & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

end