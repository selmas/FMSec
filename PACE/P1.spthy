theory P1
begin

/*
  Assignment 1.1: MAC-based challenge response

  We model the following protocol:
    1. A -> B: x
    2. B -> A: [x]k(A,B)
  where x is a nonce generated by A
  k(A,B) is a uni-directional symmetric long-term key shared by A and B and
  [M]k denotes the MAC of message M with key K  
*/

builtins: symmetric-encryption
functions: mac/2
equations: mac(m,k) = <m,senc(m,k)>

rule Register:
	[ Fr(~sk) ]
	--[ Register($I,$R) ]-> 
	[ !Lkt($I, $R, ~sk) ]

rule Reveal_I:
	[!Lkt(I,R,ltk)]
	--[Reveal(I)]->
	[Out(ltk)]
	
rule Reveal_R:
	[!Lkt(I,R,ltk)]
	--[Reveal(R)]->
	[Out(ltk)]

rule Init_I:	
	[ Fr(~id)
	, !Lkt(I, R, sk_IR)
	] 
	--[ Create(I, ~id, 'I') ]->
	[ St_I_1(I, ~id, R, sk_IR) ] 

rule Init_R:
	[ Fr(~id)
	, !Lkt(I, R, sk_IR)
	] 
	--[ Create(R, ~id, 'R') ]->
	[ St_R_1(R, ~id, I, sk_IR) ] 


rule I_1_Send:
	[ Fr(~x)
	, St_I_1(I, ~id, R, sk_IR) ]
	--[ Send(~x) ]->
	[ Out(~x)
	, St_I_2(I, ~id, R, sk_IR, ~x) 
	]

rule R_1_Recv:
	[ In(x)
	, St_R_1(R, ~id, I, sk_IR) ]
	--[ Receive(x) ]->
	[ St_R_2(R, ~id, I, sk_IR, x) ]

rule R_2_Send:
	let m = mac(x, sk_IR)
	in
	[ St_R_2(R, ~id, I, sk_IR, x) ] 
	--[ Running(R, I, <'I', 'R', x>)
	, Send(m) ]->
	[ Out(m)
	, St_R_2(R, ~id, I, sk_IR, x) ] 

rule I_2_Recv:
	let m = mac(x, sk_IR)
	in
	[ In(m)
	, St_I_2(I, ~id, R, sk_IR, x) ]
	--[ Secret(I, sk_IR)
	, Secret(R, sk_IR)
	, Honest(I)
	, Honest(R)
	, Commit(I, R, <'I', 'R', x>)
	, Receive(m)
	, Finish() ]->
	[ St_I_3(I, ~id, R, sk_IR, x) ]

restriction onekeyperpair:
  "All A B #i #j. Register(A,B)@i & Register(A,B)@j ==> #i = #j"


lemma executable:
  exists-trace
    "Ex #i. Finish() @i
    "

lemma secrecy:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma secrecy_PFS:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i & r < i)"

lemma noninjectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a,b,<'I','R',t>) @i
    ==> (Ex #j. Running(b,a,<'I','R',t>) @j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma injectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a,b,<'I','R',t>) @i
    ==> (Ex #j. Running(b,a,<'I','R',t>) @j 
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>) @i2
                           & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma noninjectiveagreementRESPONDER:
  "All a b t #i. 
    Commit(a,b,<'R','I',t>) @i
    ==> (Ex #j. Running(b,a,<'R','I',t>) @j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma injectiveagreementRESPONDER:
  "All a b t #i. 
    Commit(a,b,<'R','I',t>) @i
    ==> (Ex #j. Running(b,a,<'R','I',t>) @j 
              & not (Ex a2 b2 #i2. Commit(a2,b2,<'R','I',t>) @i2
                                 & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

end