theory P1
begin

/*
  Assignment 1.1: MAC-based challenge response

  We model the following protocol:
    1. A -> B: x
    2. B -> A: [x]k(A, B)
    
  where x is a nonce generated by A
  k(A, B) is a uni-directional symmetric long-term key shared by A and B and
  [M]k denotes the MAC of message M with key K  
*/

builtins: symmetric-encryption
functions: mac/2
equations: mac(m, k) = <m, senc(m, k)>

rule Register:
	[ Fr(~sk) ]
	--[ Register($I, $R) ]-> 
	[ !Lkt($I, $R, ~sk) ]

rule Reveal_I:
	[!Lkt($I, $R, ltk)]
	--[Reveal($I)]->
	[Out(ltk)]
	
rule Reveal_R:
	[!Lkt($I, $R, ltk)]
	--[Reveal($R)]->
	[Out(ltk)]

rule Init_I:	
	[ Fr(~id)
	, !Lkt($I, $R, sk_IR)
	] 
	--[ Create($I, ~id, 'I') ]->
	[ St_I_1($I, ~id, $R, sk_IR) ] 

rule Init_R:
	[ Fr(~id)
	, !Lkt($I, $R, sk_IR)
	] 
	--[ Create($R, ~id, 'R') ]->
	[ St_R_1($R, ~id, $I, sk_IR) ] 


rule I_1_Send:
	[ Fr(~x)
	, St_I_1($I, id, $R, sk_IR) ]
	--[ Send_I_1(~x) ]->
	[ Out(~x)
	, St_I_2($I, id, $R, sk_IR, ~x) 
	]

rule R_1_Recv:
	[ In(x)
	, St_R_1($R, id, $I, sk_IR) ]
	--[ Receive_R_1(x) ]->
	[ St_R_2($R, id, $I, sk_IR, x) ]

rule R_2_Send:
	let m1 = mac(x, sk_IR)
	in
	[ St_R_2($R, id, $I, sk_IR, x) ] 
	--[ Running($R, $I, <'I', 'R', x>)
	, Send_R_2(m1) ]->
	[ Out(m1)
	, St_R_3($R, id, $I, sk_IR, x) ] 

rule I_2_Recv:
	let m2 = mac(x, sk_IR)
	in
	[ In(m2)
	, St_I_2($I, id, $R, sk_IR, x) ]
	--[ Honest($I)
	, Honest($R)
	, Commit($I, $R, <'I', 'R', x>)
	, Receive_I_2(m2)
	, Finish() ]->
	[ St_I_3($I, id, $R, sk_IR, x) ]

restriction onekeyperpair:
  "All A B #i #j. Register(A, B)@i & Register(A, B)@j ==> #i = #j"

// This lemma gets verified
lemma executable:
  exists-trace
    "Ex #i. Finish() @i"

// This lemma gets verified
lemma noninjectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a, b, <'I', 'R', t>) @i
    ==> (Ex #j. Running(b, a, <'I', 'R', t>) @j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

// This lemma gets verified
lemma injectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a, b, <'I', 'R', t>) @i
    ==> (Ex #j. Running(b, a, <'I', 'R', t>) @j 
        & not (Ex a2 b2 #i2. Commit(a2, b2, <'I', 'R', t>) @i2
                           & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

end